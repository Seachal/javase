                                                     外观模式
类型：结构型
定义：为子系统中的一组接口提供一个一致的界面,Facade模式定义了一个高层接口。这个接口使得这一子系统更加容易使用
    界面：这里指的是从一个组件外部来看这个组件,能够看到什么,也就是这个组件的界面,也就是所说的外观
    接口：这里指的是外部和内部交互的这么一个通道,通常是指一些方法,可以是类的方法,也可以是interface的方法。


场景问题：组装电脑
   方式一：去电子市场把自己需要的配件都买回来，然后自己组装，需要对各种配件都比较熟悉，还要考虑各个配件之间的兼容性
   方式二：到电子市场找一家专业的装机公司,把具体的要求提出来,然后等着电脑就好了。这个专业的公司就相当于外观模式
  
    如果把电子市场看成一个系统，而各个卖配件的公司看成是模块的话,就类似于出现这样一种情况：客户端为了完成某个功能
，需要调用某个系统的多个模块，假如A,B,C模块，对应客户端而言，那就需要知道A,B,C这三个模块的功能，还需要知道如何组
合这多个模块提供的功能来实现自己需要的功能，非常麻烦。               
   
   问题：客户端在使用子系统的时候，既能简单地使用这些子系统内部的模块功能, 而又不用客户端去与子系统内部的多个模块
   交互呢？  
        外观模式就是通过引入这么一个外观类,在这个类里面定义客户端想要的简单的方法，然后在这些方法的实现里面,由外观类再去
 分别调用内部的多个模块了来实现功能。从而让客户端变得简单，这样客户端只需要和外观类交互就可以了。                     
                                                          模块A
                      .
                     .
   客户端......>外观类 . .模块B        
                     .
                       .模块C        
                       
 1.Facade
      定义子系统的多个模块对外的高层接口,通常需要调用内部多个模块,从而把客户的请求代理给适当的子系统对象。
 2.模块
      接受Facade对象的委派,真正实现功能，各个模块之间可能有交互
      注意：Facade对象知道各个模块,但是各个模块不应该知道Facade对象。
                       
 ApiA......ImplA       ApiB......ImplB     ApiC......ImplC

   public class Client{
        public void doSomething(){    
           //1.如果不用外观模式 需要知道每一个模块的具体实现
		     ApiA apiA=new ImplA();
		     ApiB apiB=new ImplB();
		     ApiC apiC=new ImplC();
             apiA.doSomething();
             apiB.doSomething();
             apiC.doSomething();
           
          //2.使用外观模式  客户端不需要知道内部具体的实现  也不用和各模块进行交互
          new　Facade().doSomething();
        
        }
   }      
   
   //外观类
   class Facade{
   
    public static void doSomething(){
             ApiA apiA=new ImplA();
             ApiB apiB=new ImplB();
             ApiC apiC=new ImplC();
             apiA.doSomething();
             apiB.doSomething();
             apiC.doSomething();
    }
   }             
                       
外观模式的目的：不是给子系统添加新的功能接口,而是为了让外部减少与子系统内部多个模块的交互,松散耦合,从而让外部
       更加简单地使用子系统。另外一个好处是Facade的功能可以被很多个客户端调用,也就是说Facade可以实现功能的共享，
     也就是实现复用，同样的调用代码就只用在Facade里面写一次就好了，而不用在多个调用的地方重复写。再者,对使用
     Facade的人员来说,Facade大大节省了它们的学习成本,他们只需要了解Facade即可,无须再深入到子系统内部,去了解每
     个模块的细节,也不用和多个模块交互,从而使得开发简单,学习也容易。还有,有外观,但是可以不使用，虽然有了外观,但是
     可以不使用,如果有需要,外部还是可以直接调用某个具体模块的接口，这样就能实现兼顾组合功能和细节功能。比如客户端
     就想要使用A模块的功能,那么就不需要使用Facade,可以直接调用A模块的接口。
       注意： 因为外观是当作子系统对外的接口出现的,虽然也可以再这里定义一下子系统没有的功能,但不建议这么做,外观
               应该是包装已有的功能， 它主要负责组合已有功能来实现客户需要，而不是添加新的实现。 一般来说,对于一个子
               系统而言,外观类不需要很多，通常可以实现成为一个单例。
 
 本质：封装交互,简化调用
    Facade封装了子系统外部和子系统内部多个模块交互过程,从而简化了外部的调用.
    
对设计原则的体现：
    体现了"最少知识原则",如果不使用外观模式,客户端通常需要和子系统内部的多个模块交互,客户端和这些模块之间有依赖关系
   任意一个模块的变动都可能会引起客户端的变动。
   使用外观模式后，客户端只和外观类交互，不需要关心系统内部模块的变动情况了,客户端只和这个外观类有依赖关系。
   
 何时选用外观模式？
   1.为一个复杂的子系统提供一个简单接口,使用外观对象来实现大部分客户需要的功能，从而简化客户的需要。
   2.如果想要让客户程序和抽象类的实现部分松散耦合,使用外观对象将这个子系统与它的客户分离开来,从而提高子系统的
        独立性和可移植性(和客户端没有依赖关系)。  
   3.如果构建多层结构的系统,可以考虑使用外观模式,使用外观对象作为每层的入口,这样可以简化层间的调用,也可以松散
        层次之间的依赖关系。                 
                        
                       
                       
                       
                       
                       
                       
                       
                       
                       