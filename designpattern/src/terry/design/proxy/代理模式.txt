
                                 代理模式
类型：结构性
定义：为其他对象提供一种代理以控制对这个对象的访问
结构：
Proxy：代理类,实现与目标对象一样的接口，这样就可以使用代理来代替具体的目标对象
Subject：目标接口,定义代理和具体目标对象的接口，这样就可以在任何使用具体目标对象的地方使用代理对象
RealSubject:具体的目标对象,真正实现目标接口要求的功能

标准实现：

//目标接口,定义具体的目标对象和代理公用的接口
public interface Subject{
    public void request();
}
//具体的目标对象,是真正被代理的对象
public class RealSubject implements Subject{
    public void request(){
      //执行具体的功能处理
    }
}
//代理对象
public class Proxy implements Subject{
  Subject realSubject=null;//持有被代理的具体的目标对象
  
  public Proxy(Subject realSubject){
    this.realSubject=realSubject;
    }
    
    public void request(){
     //在转调具体的目标对象前，可以执行一些功能处理
     
      realSubject.request();
      
     //在转调具体的目标对象后，可以执行一些功能处理 
    }
}


模式讲解：
当客户端操作这个代理对象的时候，实际上功能最终还是会由真实的对象来完成，只不过是通过代理操作的，也就是客户端操作代理，代理操作真正的对象。
通常把前面自己实现的代理模式称为Java的静态代理，这种实现方式有一个极大的缺点，就是如果Subject接口发生变化，那么代理类和具体的目标实现都要
变化，不是很灵活。而java内建的对代理模式支持的功能就没有这个问题。称为Java的动态代理。java的动态代理目前只能代理接口，基本实现是依靠Java
的反射机制和动态生成calss的技术，来动态生成被代理的接口的实现对象。如果要实现类的代理，可以使用cglib。与静态代理相比，动态代理在实现的时候，
虽然Subject接口上定义了很多方法，但是动态代理类始终只有一个invoke方法。这样，当Subject接口发生变化的时候，动态代理的接口就不需要跟着变化了。

代理模式的本质：控制对象访问
代理模式通过代理目标对象，把代理对象插入到客户和目标对象之间,从而为客户和目标对象引入一定的间接性。代理对象可以在调用具体的目标对象前后，附加
很多操作，从而实现新的功能或是扩展目标对象的功能。同时还可以使用对象继承的方式来实现代理，
 public　class Proxy extends RealSubject{
     public Proxy(){
      super()
     }
     public void request(){
       if(xxxx){  //如果满足要求  则转调父类的方法
         super.request();
       }
     }
 }
何时使用代理模式？
1.需要控制对原始对象的访问的时候,可以使用保护代理
2.需要在访问对象执行一些附加操作的时候，可以使用智能指引代理
3.需要按照需要创建开销很大的对象(对象属性很多)的时候，可以使用虚代理
4.需要为一个对象在不同的地址空间提供局部代表的时候，可以使用远程代理


与适配器模式的区别：适配器模式主要用来解决接口之间的不匹配的问题,它通常是为所适配的对象(Adaptee)提供一个不同的接口，而代理模式会实现与目标对象相同的接口。
而且代理类可在转调具体的目标对象前后，可以执行一些功能处理，是对原目标对象功能的增强


























